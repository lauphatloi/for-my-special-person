<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Breath of Stars</title>
  <style>
    body { 
      margin: 0; background-color: #000; overflow: hidden; 
      font-family: sans-serif; color: white; touch-action: none;
    }
    canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    video { display: none; }
    
    /* UI Overlay */
    #ui {
      position: absolute; bottom: 30px; left: 0; width: 100%;
      text-align: center; pointer-events: none; z-index: 10;
      text-shadow: 0 0 5px black;
    }
    h1 { font-size: 16px; margin: 0; letter-spacing: 2px; text-transform: uppercase; color: #aaa; }
    #status { font-size: 24px; font-weight: bold; color: white; margin-top: 5px;}

    /* Start Button */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    button {
      padding: 15px 40px; font-size: 18px; background: white; color: black;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold;
    }
  </style>
</head>
<body>

  <div id="start-screen">
    <button id="start-btn">TAP TO START</button>
    <p style="margin-top:10px; font-size:12px; color:#666">Allow Camera Access</p>
  </div>

  <div id="ui">
    <h1>Current State</h1>
    <div id="status">Waiting...</div>
  </div>
  
  <video id="webcam" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const video = document.getElementById('webcam');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');

    let handLandmarker = undefined;
    let particles = [];
    let handX = 0, handY = 0;
    let gestureState = "NONE"; // NONE, OPEN, CLOSED

    // --- 1. SETUP & CAMERA ---
    async function setup() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "CPU" // Use CPU for iPhone stability
        },
        runningMode: "VIDEO",
        numHands: 1
      });
      startBtn.innerText = "START";
    }

    startBtn.addEventListener('click', () => {
      navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "user", width: 640, height: 480 } 
      }).then((stream) => {
        video.srcObject = stream;
        video.onloadeddata = () => {
          startScreen.style.display = 'none';
          initParticles();
          loop();
        };
      });
    });

    // --- 2. LOGIC: FIST vs OPEN HAND ---
    function detectState(landmarks) {
      const wrist = landmarks[0];
      const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky tips
      const bases = [5, 9, 13, 17]; // Corresponding knuckles (MCP)

      let extendedFingers = 0;

      // Check each finger (excluding thumb for simplicity)
      for (let i = 0; i < 4; i++) {
        const tip = landmarks[tips[i]];
        const base = landmarks[bases[i]];
        
        // Calculate distance from wrist
        const tipDist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
        const baseDist = Math.hypot(base.x - wrist.x, base.y - wrist.y);

        // If tip is significantly further from wrist than the knuckle, it's open
        if (tipDist > baseDist * 1.3) {
          extendedFingers++;
        }
      }

      // Logic Thresholds
      if (extendedFingers >= 3) return "OPEN";   // 3 or more fingers open
      if (extendedFingers <= 1) return "CLOSED"; // 0 or 1 finger open (Fist)
      return "NEUTRAL"; // In between
    }

    // --- 3. PARTICLE SYSTEM ---
    class Particle {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = (Math.random() - 0.5) * 1;
        this.size = Math.random() * 2 + 1;
        this.color = `hsl(${Math.random() * 60 + 180}, 100%, 70%)`; // Cyan/Blue tones
        this.friction = 0.96;
      }

      update() {
        if (gestureState === "CLOSED") {
          // --- ATTRACTION (Black Hole) ---
          // Particles rush TOWARDS the hand
          let dx = handX - this.x;
          let dy = handY - this.y;
          this.x += dx * 0.15; // Speed of attraction
          this.y += dy * 0.15;
          this.color = '#FFD700'; // Turn Gold
          
        } else if (gestureState === "OPEN") {
          // --- REPULSION (Explosion) ---
          // Particles rush AWAY from the hand
          let dx = this.x - handX;
          let dy = this.y - handY;
          let dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist < 400) { // Interaction radius
            let force = (400 - dist) / 400;
            let angle = Math.atan2(dy, dx);
            this.vx += Math.cos(angle) * force * 2;
            this.vy += Math.sin(angle) * force * 2;
            this.color = '#FF0055'; // Turn Pink/Red
          }
        } 

        // Apply Velocity & Friction
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Keep bounds (wrap around screen)
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function initParticles() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      particles = [];
      for(let i=0; i<400; i++) particles.push(new Particle());
    }

    // --- 4. ANIMATION LOOP ---
    async function loop() {
      // Clear with slight trail effect
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Detect Hand
      if (handLandmarker && video.videoWidth > 0) {
        let now = performance.now();
        const result = handLandmarker.detectForVideo(video, now);

        if (result.landmarks && result.landmarks.length > 0) {
          const lm = result.landmarks[0];
          
          // Get Palm Center (approximate between wrist and middle finger)
          // Mirror X coordinate
          handX = (1 - lm[9].x) * canvas.width; 
          handY = lm[9].y * canvas.height;

          // Determine State
          gestureState = detectState(lm);
          
          // Update Text
          if(gestureState === "OPEN") statusDiv.innerText = "OPEN ðŸ’¥";
          else if(gestureState === "CLOSED") statusDiv.innerText = "CLOSED âœŠ";
          else statusDiv.innerText = "Hand Detected âœ‹";

        } else {
          gestureState = "NONE";
          statusDiv.innerText = "Show Hand...";
        }
      }

      // Update Particles
      for (let p of particles) {
        p.update();
        p.draw();
      }

      requestAnimationFrame(loop);
    }

    // Init
    startBtn.innerText = "Loading AI...";
    setup();

  </script>
</body>
</html>

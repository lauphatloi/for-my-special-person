<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Magic Gestures</title>
  <style>
    body { 
      margin: 0; 
      padding: 0; 
      background-color: #050505; 
      overflow: hidden; 
      touch-action: none; /* Prevents scrolling on mobile */
      font-family: 'Courier New', Courier, monospace;
    }

    /* Full screen canvas */
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* Hide the raw webcam video */
    video {
      display: none;
      transform: scaleX(-1);
    }

    /* Status indicator for testing gestures */
    #status {
      position: absolute;
      bottom: 30px;
      left: 0;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.5);
      font-size: 14px;
      z-index: 10;
      pointer-events: none;
    }

    /* Loading overlay */
    #loader {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 18px;
      z-index: 20;
      text-align: center;
    }
  </style>
</head>
<body>

  <div id="loader">Initializing Magic...<br><span style="font-size:12px; opacity:0.7">Please Allow Camera Access</span></div>
  <div id="status">Waiting for hand...</div>
  
  <!-- "playsinline" is critical for iPhone Safari -->
  <video id="webcam" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const video = document.getElementById('webcam');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const loader = document.getElementById('loader');

    let handLandmarker = undefined;
    let particles = [];
    let lastTime = 0;
    
    // Tracking Variables
    let handDetected = false;
    let gestureMode = "IDLE"; // IDLE, POINT, PINCH, OPEN
    let interactionX = 0;
    let interactionY = 0;

    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 350; // Keep roughly 300-400 for smooth iPhone 15 performance
    const COLORS_DEFAULT = ['#00FFFF', '#FFD700', '#FFFFFF', '#A020F0']; // Cyan, Gold, White, Purple
    const COLORS_HEART = ['#FF0000', '#FF1493', '#FF69B4']; // Red, DeepPink, HotPink

    // --- PARTICLE SYSTEM ---
    class Particle {
      constructor() {
        this.reset();
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
      }

      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 2 + 1;
        this.baseX = this.x;
        this.baseY = this.y;
        this.vx = (Math.random() - 0.5) * 0.5;
        this.vy = (Math.random() - 0.5) * 0.5;
        this.color = COLORS_DEFAULT[Math.floor(Math.random() * COLORS_DEFAULT.length)];
        this.friction = 0.95;
      }

      update() {
        // Physics Logic based on Gesture Mode
        
        // 1. PINCH MODE: Strong Attraction (Heartbeat)
        if (gestureMode === "PINCH") {
          this.color = COLORS_HEART[Math.floor(Math.random() * COLORS_HEART.length)];
          let dx = interactionX - this.x;
          let dy = interactionY - this.y;
          // Move fast towards center
          this.x += dx * 0.08;
          this.y += dy * 0.08;
          // Add a little jitter for "energy"
          this.x += (Math.random() - 0.5) * 2;
          this.y += (Math.random() - 0.5) * 2;
        
        // 2. OPEN HAND MODE: Repulsion (Big Bang)
        } else if (gestureMode === "OPEN") {
          this.color = '#FFFFFF';
          let dx = this.x - interactionX;
          let dy = this.y - interactionY;
          let distance = Math.sqrt(dx*dx + dy*dy);
          
          if (distance < 300) {
            let force = (300 - distance) / 300;
            let angle = Math.atan2(dy, dx);
            this.x += Math.cos(angle) * force * 15; // Push away hard
            this.y += Math.sin(angle) * force * 15;
          }

        // 3. POINT MODE: Gentle Trail
        } else if (gestureMode === "POINT") {
          // Revert to default colors slowly
          if (Math.random() < 0.05) this.color = COLORS_DEFAULT[Math.floor(Math.random() * COLORS_DEFAULT.length)];
          
          let dx = interactionX - this.x;
          let dy = interactionY - this.y;
          let distance = Math.sqrt(dx*dx + dy*dy);
          
          if (distance < 150) {
             this.x += dx * 0.05;
             this.y += dy * 0.05;
          }
        } 
        
        // IDLE / Drift Physics (Always active slightly)
        if (gestureMode !== "PINCH") {
          this.x += this.vx;
          this.y += this.vy;

          // Return slowly to base if no strong interaction
          if (!handDetected) {
            this.x += (this.baseX - this.x) * 0.02;
            this.y += (this.baseY - this.y) * 0.02;
          }
        }
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function initParticles() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      particles = [];
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        particles.push(new Particle());
      }
    }

    // --- GESTURE RECOGNITION ---
    function detectGesture(landmarks) {
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const middleTip = landmarks[12];
      const ringTip = landmarks[16];
      const pinkyTip = landmarks[20];
      const wrist = landmarks[0];

      // Distance between Thumb and Index
      const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

      // Check if fingers are open (Tip is higher than PIP joint - y is inverted in MP often, but let's use relative dist to wrist)
      // Simple check: Are other fingers extended?
      // We'll use a simple bounding box check or distance from wrist
      const middleExtended = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y) > 0.2;
      const pinkyExtended = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y) > 0.2;

      // 1. PINCH DETECTION
      if (pinchDist < 0.06) {
        return "PINCH";
      }
      
      // 2. OPEN HAND (High Five)
      // If Thumb/Index are far apart AND Middle/Pinky are extended
      if (pinchDist > 0.1 && middleExtended && pinkyExtended) {
        return "OPEN";
      }

      // 3. POINTING (Index only)
      // If Middle and Pinky are curled (close to wrist) but Index is not
      if (!middleExtended && !pinkyExtended) {
        return "POINT";
      }

      return "HOVER"; // Just hand present
    }

    // --- MEDIAPIPE SETUP ---
    async function setupMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "GPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });

      startCamera();
    }

    function startCamera() {
      navigator.mediaDevices.getUserMedia({ 
        video: { 
          width: { ideal: 640 },
          height: { ideal: 480 },
          facingMode: "user" 
        } 
      }).then((stream) => {
        video.srcObject = stream;
        video.addEventListener("loadeddata", () => {
          loader.style.display = 'none';
          requestAnimationFrame(loop);
        });
      });
    }

    // --- MAIN LOOP ---
    async function loop() {
      // 1. Draw Background
      // ctx.clearRect(0, 0, canvas.width, canvas.height); // Standard clear
      
      // Cool trail effect (instead of clearRect):
      ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 2. Detect Hand
      if (handLandmarker && video.currentTime !== lastTime) {
        lastTime = video.currentTime;
        let startTimeMs = performance.now();
        const result = handLandmarker.detectForVideo(video, startTimeMs);

        if (result.landmarks && result.landmarks.length > 0) {
          handDetected = true;
          const lm = result.landmarks[0];
          
          // Get screen coordinates for Index Finger
          // Mirror X because we are using a selfie camera
          interactionX = (1 - lm[8].x) * canvas.width;
          interactionY = lm[8].y * canvas.height;

          // Determine Gesture
          gestureMode = detectGesture(lm);
          
          // Update Status Text
          let icon = "";
          if (gestureMode === "PINCH") icon = "‚ù§Ô∏è HEARTBEAT";
          else if (gestureMode === "OPEN") icon = "üí• EXPLODE";
          else if (gestureMode === "POINT") icon = "‚ú® STARDUST";
          else icon = "‚úã DETECTED";
          
          statusDiv.innerText = `Status: ${icon}`;

        } else {
          handDetected = false;
          gestureMode = "IDLE";
          statusDiv.innerText = "Waiting for hand...";
        }
      }

      // 3. Update Particles
      for (let p of particles) {
        p.update();
        p.draw();
      }

      requestAnimationFrame(loop);
    }

    // Handle Resize
    window.addEventListener('resize', initParticles);

    // Start
    initParticles();
    setupMediaPipe();

  </script>
</body>
</html>

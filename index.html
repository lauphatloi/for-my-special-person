
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Eye of the Ocean</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
    
    /* The Hidden Message Layer (Behind the Canvas) */
    #hidden-layer {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 1; /* Bottom layer */
    }

    .message {
      color: #fff;
      font-family: 'Helvetica', sans-serif;
      font-weight: 800;
      font-size: 2.5rem;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 5px;
      text-shadow: 0 0 20px #ff007f, 0 0 40px #00ffff;
      opacity: 0.9;
    }
    
    .sub-text {
      font-size: 1rem; color: #aaa; margin-top: 20px;
      font-weight: normal; letter-spacing: 2px;
    }

    /* The Water Canvas (Top Layer) */
    canvas { 
      display: block; width: 100vw; height: 100vh; 
      position: absolute; top: 0; left: 0;
      z-index: 2; /* Top layer */
    }
    
    /* UI Overlay */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; text-align: center;
    }
    button {
      padding: 15px 40px; font-size: 18px; background: white; color: black;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold; margin-top: 25px;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    }
    #debug {
      position: absolute; top: 10px; left: 10px; color: lime; 
      font-size: 10px; z-index: 50; pointer-events: none;
    }
  </style>
</head>
<body>

  <!-- 1. THE HIDDEN CONTENT (Revealed by looking) -->
  <div id="hidden-layer">
    <div class="message">
      My Heart<br>Beats For<br>You
    </div>
    <div class="sub-text">Look around to find me<br>Blink to make waves</div>
  </div>

  <!-- 2. START SCREEN -->
  <div id="start-screen">
    <div style="font-size:50px; margin-bottom:10px">üëÅÔ∏è</div>
    <h1 style="letter-spacing: 3px; margin:0;">Ocean Gaze</h1>
    <p style="font-size:13px; color:#aaa; margin-top:15px; max-width: 80%;">
      We need to see your eyes.<br>
      Look around to clear the water.<br>
      Blink to create ripples.
    </p>
    <button id="start-btn">START</button>
  </div>

  <div id="debug">Initializing...</div>

  <!-- 3. CANVAS FOR SHADER -->
  <div id="container"></div>

  <!-- IMPORTS -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, FaceLandmarker } from "@mediapipe/tasks-vision";

    // --- VARIABLES ---
    let camera, scene, renderer, mesh;
    let faceLandmarker = undefined;
    let video = document.createElement('video');
    let lastVideoTime = -1;

    // Gaze & Blink Logic
    let gazeX = 0.5; // Center
    let gazeY = 0.5; // Center
    let targetGazeX = 0.5;
    let targetGazeY = 0.5;
    let blinkStrength = 0.0; // 0 = no blink, 1 = blink

    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const debugDiv = document.getElementById('debug');

    // --- 1. THE AMAZING WATER SHADER ---
    // This runs on the GPU. It creates blue noise + a "hole" based on gaze.
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const fragmentShader = `
      uniform float uTime;
      uniform vec2 uResolution;
      uniform vec2 uGaze;      // The user's eye position (0-1)
      uniform float uBlink;    // Shockwave strength

      varying vec2 vUv;

      // Noise Function
      float random (in vec2 st) {
          return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
      }
      float noise (in vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);
          float a = random(i);
          float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0));
          float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }

      void main() {
        // Aspect Ratio Correction for circular ripples
        vec2 uv = vUv;
        vec2 aspectCorrectedUV = uv;
        aspectCorrectedUV.x *= uResolution.x / uResolution.y;
        
        vec2 gazeCorrected = uGaze;
        gazeCorrected.x *= uResolution.x / uResolution.y;

        // 1. WATER TEXTURE (FBM Noise)
        float n = noise(uv * 3.0 + uTime * 0.2);
        n += noise(uv * 6.0 - uTime * 0.3) * 0.5;
        
        // 2. BLINK SHOCKWAVE
        // Distance from center (or gaze)
        float distFromCenter = distance(aspectCorrectedUV, vec2(0.5 * uResolution.x/uResolution.y, 0.5));
        
        // Create a ring that expands
        float rippleRadius = mod(uTime * 2.0, 2.0); // Continual subtle ripples
        if (uBlink > 0.01) {
            // Big blast if blinking
             rippleRadius = uBlink * 3.0; // Expand fast
        }
        
        float ripple = sin(distFromCenter * 20.0 - uTime * 5.0 + (uBlink * 20.0));
        
        // 3. COLOR PALETTE (Deep Ocean)
        vec3 deepBlue = vec3(0.0, 0.05, 0.2);
        vec3 cyan = vec3(0.0, 0.6, 0.8);
        vec3 color = mix(deepBlue, cyan, n * 0.5 + 0.2);
        
        // Add ripple brightness
        color += vec3(ripple * uBlink * 0.5);

        // 4. THE GAZE "HOLE"
        // Calculate distance from current pixel to the gaze point
        float distToGaze = distance(aspectCorrectedUV, gazeCorrected);
        
        // Create a smooth circle mask
        // smoothstep(edges, center, dist)
        float gazeMask = smoothstep(0.15, 0.35, distToGaze); // 0.15 is hole size
        
        // Add wobbly edges to the hole (liquid edges)
        gazeMask += noise(uv * 10.0 + uTime) * 0.1;
        gazeMask = clamp(gazeMask, 0.0, 1.0);

        // 5. COMBINE
        // If gazeMask is 0 (center of eye), alpha is 0 (Transparent)
        // If gazeMask is 1 (far away), alpha is 0.95 (Opaque water)
        gl_FragColor = vec4(color, gazeMask * 0.98); 
      }
    `;

    // --- 2. THREE.JS SETUP ---
    function initThree() {
      const container = document.getElementById('container');
      
      camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      scene = new THREE.Scene();

      // Create a plane that covers the screen
      const geometry = new THREE.PlaneGeometry(2, 2);
      
      const uniforms = {
        uTime: { value: 0 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uGaze: { value: new THREE.Vector2(0.5, 0.5) },
        uBlink: { value: 0.0 }
      };

      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms,
        transparent: true
      });

      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      renderer = new THREE.WebGLRenderer({ alpha: true }); // Alpha true allows seeing behind canvas
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);

      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        mesh.material.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
      });
    }

    // --- 3. MEDIAPIPE FACE SETUP ---
    async function setupFaceLandmarker() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      
      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO",
        numFaces: 1,
        refineLandmarks: true // IMPORTANT: This enables Iris tracking
      });
      
      startBtn.innerText = "START EXPERIENCE";
      startBtn.disabled = false;
    }

    // --- 4. LOGIC: BLINK & GAZE ---
    function analyzeFace(landmarks) {
      // A. BLINK DETECTION
      // Left Eye: 159 (upper), 145 (lower)
      // Right Eye: 386 (upper), 374 (lower)
      const leftEyeDist = Math.hypot(landmarks[159].x - landmarks[145].x, landmarks[159].y - landmarks[145].y);
      const rightEyeDist = Math.hypot(landmarks[386].x - landmarks[374].x, landmarks[386].y - landmarks[374].y);
      
      // Face scale (approx distance between eyes) used to normalize blink
      const faceScale = Math.hypot(landmarks[33].x - landmarks[263].x, landmarks[33].y - landmarks[263].y);
      
      // Normalized aperture
      const eyeOpenness = (leftEyeDist + rightEyeDist) / 2 / faceScale;

      // If openness is small, we are blinking
      if (eyeOpenness < 0.035) {
         blinkStrength = 1.0; // Trigger Ripple
         debugDiv.innerText = "Status: BLINK DETECTED üåä";
      } else {
         // Decay blink strength
         blinkStrength *= 0.95;
         if(blinkStrength < 0.01) blinkStrength = 0;
         debugDiv.innerText = "Status: Tracking Eyes...";
      }

      // B. GAZE DETECTION (Simplified Iris Tracking)
      // We use the Left Iris Center (468)
      // To make it intuitive without calibration, we assume looking 'center' is the middle of the screen
      // and we amplify small eye movements.
      
      const iris = landmarks[468]; // Center of Left Iris
      // We need head position to know relative movement
      const faceCenter = landmarks[1]; // Nose tip

      // Calculate relative look direction (Inverted X because of mirror effect)
      // We amplify the difference between Iris and Nose
      const sensitivity = 2.5;
      const dx = (faceCenter.x - iris.x) * sensitivity;
      const dy = (faceCenter.y - iris.y) * sensitivity;

      // Map to screen coordinates (0.5 is center)
      let rawX = 0.5 + dx;
      let rawY = 0.5 + dy; // Y usually doesn't need inversion if css matches

      // Invert X for mirroring feel
      rawX = 1.0 - rawX;

      // Clamp to screen
      targetGazeX = Math.max(0, Math.min(1, rawX));
      targetGazeY = Math.max(0, Math.min(1, rawY));
    }

    startBtn.addEventListener('click', () => {
      startBtn.innerText = "Accessing Camera...";
      navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "user", width: 640, height: 480 } 
      }).then((stream) => {
        video.srcObject = stream;
        video.playsInline = true; 
        video.autoplay = true;
        video.onloadeddata = () => {
          startScreen.style.opacity = 0;
          setTimeout(() => startScreen.style.display = 'none', 1000);
          initThree();
          loop();
        };
      }).catch(err => alert("Camera error: " + err));
    });

    // --- 5. LOOP ---
    function loop() {
      requestAnimationFrame(loop);

      // Vision Process
      if (faceLandmarker && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const result = faceLandmarker.detectForVideo(video, performance.now());
        
        if (result.faceLandmarks && result.faceLandmarks.length > 0) {
          analyzeFace(result.faceLandmarks[0]);
        }
      }

      // Smooth Gaze Movement (Lerp)
      gazeX += (targetGazeX - gazeX) * 0.1;
      gazeY += (targetGazeY - gazeY) * 0.1;

      // Update Shader Uniforms
      if (mesh) {
        mesh.material.uniforms.uTime.value = performance.now() / 1000;
        mesh.material.uniforms.uGaze.value.set(gazeX, 1.0 - gazeY); // Invert Y for Shader UVs
        mesh.material.uniforms.uBlink.value = blinkStrength;
      }

      if(renderer) renderer.render(scene, camera);
    }

    setupFaceLandmarker();
  </script>
</body>
</html>

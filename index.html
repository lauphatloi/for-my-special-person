<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Magic Gestures (iOS Fix)</title>
  <style>
    body { 
      margin: 0; background-color: #000; overflow: hidden; 
      font-family: sans-serif; color: white; touch-action: none;
    }
    canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    video { display: none; } /* Hide raw video */
    
    /* Center the Start Button */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.9); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    button {
      padding: 15px 30px; font-size: 20px; background: #FF007F; color: white;
      border: none; border-radius: 50px; cursor: pointer; margin-top: 20px;
    }
    
    /* Debug Console on screen */
    #console {
      position: absolute; top: 10px; left: 10px; width: 90%;
      color: #0f0; font-size: 12px; font-family: monospace;
      pointer-events: none; z-index: 50;
      text-shadow: 1px 1px 1px #000;
    }
  </style>
</head>
<body>

  <!-- DEBUG CONSOLE -->
  <div id="console">Log:<br></div>

  <!-- START BUTTON (Required for iOS) -->
  <div id="start-screen">
    <h1>For Her</h1>
    <p>Enable Camera access when asked.</p>
    <button id="start-btn">START MAGIC</button>
  </div>
  
  <video id="webcam" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const logDiv = document.getElementById('console');
    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const video = document.getElementById('webcam');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let handLandmarker = undefined;
    let particles = [];
    let handDetected = false;
    let interactionX = 0, interactionY = 0;
    let gestureMode = "IDLE"; // IDLE, PINCH

    // --- LOGGING HELPER ---
    function log(msg) {
      logDiv.innerHTML += msg + "<br>";
      console.log(msg);
    }

    // --- 1. SETUP MEDIA PIPE ---
    async function setupMediaPipe() {
      try {
        log("Loading Vision Tasks...");
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        
        log("Creating Hand Landmarker...");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "CPU" // FORCE CPU FOR IPHONE STABILITY
          },
          runningMode: "VIDEO",
          numHands: 1
        });
        
        log("Model Loaded! Ready to start.");
        startBtn.innerText = "START MAGIC";
        startBtn.disabled = false;
        
      } catch (e) {
        log("ERROR LOADING MODEL: " + e);
      }
    }

    // --- 2. START CAMERA (User Click) ---
    startBtn.addEventListener('click', () => {
      log("Requesting Camera...");
      
      const constraints = { 
        video: { 
          facingMode: "user", 
          width: { ideal: 640 }, 
          height: { ideal: 480 } 
        } 
      };

      navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
        log("Camera Access Granted!");
        video.srcObject = stream;
        video.onloadeddata = () => {
          log("Video Data Loaded. Starting...");
          startScreen.style.display = 'none';
          initParticles();
          predictWebcam();
        };
      }).catch((err) => {
        log("CAMERA ERROR: " + err.name + " - " + err.message);
        if (location.protocol !== 'https:') {
          log("CRITICAL: You are not using HTTPS.");
        }
      });
    });

    // --- 3. PREDICTION LOOP ---
    async function predictWebcam() {
      let startTimeMs = performance.now();
      
      if (handLandmarker && video.videoWidth > 0) {
        const result = handLandmarker.detectForVideo(video, startTimeMs);
        
        // Clear Canvas with trail
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (result.landmarks && result.landmarks.length > 0) {
          handDetected = true;
          const lm = result.landmarks[0];
          const indexTip = lm[8];
          const thumbTip = lm[4];

          // Mirror X for selfie mode
          interactionX = (1 - indexTip.x) * canvas.width;
          interactionY = indexTip.y * canvas.height;

          // Detect Pinch
          const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
          if (pinchDist < 0.05) gestureMode = "PINCH";
          else gestureMode = "IDLE";
          
        } else {
          handDetected = false;
        }
      }

      // Update Particles
      for (let p of particles) {
        p.update();
        p.draw();
      }

      requestAnimationFrame(predictWebcam);
    }

    // --- 4. PARTICLE SYSTEM ---
    class Particle {
      constructor() {
        this.reset();
      }
      reset() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 1;
        this.vy = (Math.random() - 0.5) * 1;
        this.color = '#00ffff'; 
        this.size = Math.random() * 2 + 1;
      }
      update() {
        if (gestureMode === "PINCH") {
          // Heartbeat Effect
          this.color = '#ff0055';
          this.x += (interactionX - this.x) * 0.1;
          this.y += (interactionY - this.y) * 0.1;
        } else {
          // Normal Float
          this.color = '#00ffff';
          this.x += this.vx;
          this.y += this.vy;
          
          // Gentle Mouse repel
          if (handDetected) {
            let dx = this.x - interactionX;
            let dy = this.y - interactionY;
            let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 100) {
              this.x += dx * 0.05;
              this.y += dy * 0.05;
            }
          }
        }
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function initParticles() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      particles = [];
      for(let i=0; i<300; i++) particles.push(new Particle());
    }

    startBtn.innerText = "Loading Model...";
    startBtn.disabled = true;
    setupMediaPipe();

  </script>
</body>
</html>

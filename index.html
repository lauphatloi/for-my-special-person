<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Finger Heart Magic</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    /* UI Overlay */
    #ui {
      position: absolute; bottom: 40px; width: 100%; text-align: center;
      color: rgba(255, 255, 255, 0.7); pointer-events: none;
      z-index: 10;
    }
    #status { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 8px; text-shadow: 0 0 10px #ff007f; }
    .sub { font-size: 0.9rem; letter-spacing: 1px; color: #ccc; }

    /* Start Screen */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5, 5, 10, 0.95); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; text-align: center;
    }
    button {
      padding: 15px 40px; font-size: 18px; background: white; color: black;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold; margin-top: 25px;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    }
    .icon { font-size: 40px; margin-bottom: 10px; }
  </style>
</head>
<body>

  <div id="start-screen">
    <div class="icon">ü´∞</div>
    <h1 style="letter-spacing: 3px; text-transform: uppercase; margin:0;">Finger Heart</h1>
    <p style="font-size:13px; color:#aaa; max-width: 320px; line-height: 1.6; margin-top:15px;">
      1. Open Hand = <span style="color:#00ffff">Explode</span><br>
      2. Cross Thumb & Index = <span style="color:#ff007f; font-weight:bold;">Heart Shape ‚ù§Ô∏è</span>
    </p>
    <button id="start-btn">START</button>
  </div>

  <div id="ui">
    <div id="status">Waiting for hand...</div>
    <div class="sub">Make the Finger Heart gesture ü´∞</div>
  </div>

  <div id="container"></div>

  <!-- Imports -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 1600; 
    const SPHERE_RADIUS = 120;
    const HEART_SCALE = 8.5; // Size of the heart
    
    // --- VARIABLES ---
    let camera, scene, renderer, particles;
    let spherePositions = []; 
    let heartPositions = [];  
    let currentPositions = []; 
    
    let handLandmarker = undefined;
    let video = document.createElement('video');
    
    // Logic State
    let targetShape = "SPHERE"; // SPHERE, HEART
    let expansion = 1.0; 
    let lastVideoTime = -1;

    // UI
    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const statusDiv = document.getElementById('status');

    // --- 1. MATH: GENERATE HEART & SPHERE ---
    function getSpherePoint() {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = SPHERE_RADIUS * Math.cbrt(Math.random());
      return { 
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi)
      };
    }

    function getHeartPoint() {
      // 3D Heart Mathematical Formula
      let x, y, z;
      while (true) {
        // Random box
        x = (Math.random() * 4 - 2); 
        y = (Math.random() * 4 - 2); 
        z = (Math.random() * 4 - 2); 
        
        // Heart Equation
        const a = x*x + (9/4)*(y*y) + z*z - 1;
        if ((a*a*a - x*x*z*z*z - (9/80)*y*y*z*z*z) < 0) {
          break; // Point is inside heart volume
        }
      }
      return { 
        x: x * 30 * HEART_SCALE, 
        y: y * 30 * HEART_SCALE + 30, // Lift it up a bit
        z: z * 30 * HEART_SCALE 
      };
    }

    function initShapes() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        spherePositions.push(getSpherePoint());
        heartPositions.push(getHeartPoint());
        currentPositions.push({ ...spherePositions[i] });
      }
    }

    // --- 2. THREE.JS SETUP ---
    function initThree() {
      const container = document.getElementById('container');
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 500;

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050510, 0.0015);

      // Geometry
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const colors = new Float32Array(PARTICLE_COUNT * 3);
      
      const c1 = new THREE.Color(0xff007f); // Deep Pink
      const c2 = new THREE.Color(0xffffff); // White
      const c3 = new THREE.Color(0x00ffff); // Cyan

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i*3] = currentPositions[i].x;
        positions[i*3+1] = currentPositions[i].y;
        positions[i*3+2] = currentPositions[i].z;

        // Color mix
        let c = Math.random() > 0.6 ? c1 : (Math.random() > 0.5 ? c2 : c3);
        colors[i*3] = c.r;
        colors[i*3+1] = c.g;
        colors[i*3+2] = c.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      // Circular Particles
      const material = new THREE.PointsMaterial({
        size: 7,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8,
        map: createCircleTexture()
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
    }

    function createCircleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 32; canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,32,32);
      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    // --- 3. MEDIAPIPE & GESTURE LOGIC ---
    async function setupMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });
      startBtn.innerText = "START MAGIC";
      startBtn.disabled = false;
    }

    // THIS IS THE KEY FUNCTION FOR YOUR GESTURE
    function detectFingerHeart(landmarks) {
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const wrist = landmarks[0];

      // 1. Calculate Pinch Distance (Thumb to Index)
      const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

      // 2. Check if other fingers are CLOSED (curled down)
      // We check Middle(12), Ring(16), Pinky(20)
      // If Tip is closer to wrist than Knuckle(PIP), it's closed
      let otherFingersClosed = true;
      const fingersToCheck = [12, 16, 20]; // Middle, Ring, Pinky
      const knucklesToCheck = [9, 13, 17];
      
      for(let i=0; i<3; i++) {
        const tipDist = Math.hypot(landmarks[fingersToCheck[i]].x - wrist.x, landmarks[fingersToCheck[i]].y - wrist.y);
        const knuckleDist = Math.hypot(landmarks[knucklesToCheck[i]].x - wrist.x, landmarks[knucklesToCheck[i]].y - wrist.y);
        
        // If tip is further than knuckle, finger is OPEN. We want them CLOSED.
        if (tipDist > knuckleDist * 1.2) {
          otherFingersClosed = false;
        }
      }

      // --- LOGIC ---
      
      // A. FINGER HEART (Thumb close to Index + Others Closed)
      if (pinchDist < 0.1 && otherFingersClosed) {
        return "HEART";
      }

      // B. EXPLODE (Open Hand - All fingers extended)
      // Quick check: If pinky is far from wrist
      const pinkyDist = Math.hypot(landmarks[20].x - wrist.x, landmarks[20].y - wrist.y);
      if (pinkyDist > 0.3 && !otherFingersClosed) {
        return "OPEN";
      }

      return "NEUTRAL";
    }

    startBtn.addEventListener('click', () => {
      startBtn.innerText = "Initializing...";
      navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "user", width: 640, height: 480 } 
      }).then((stream) => {
        video.srcObject = stream;
        video.playsInline = true; 
        video.autoplay = true;
        video.onloadeddata = () => {
          startScreen.style.opacity = 0;
          setTimeout(() => startScreen.style.display = 'none', 1000);
          initShapes();
          initThree();
          loop();
        };
      }).catch(err => alert("Camera blocked: " + err));
    });

    // --- 4. ANIMATION LOOP ---
    async function loop() {
      requestAnimationFrame(loop);

      // A. Detect Hand
      if (handLandmarker && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const result = handLandmarker.detectForVideo(video, performance.now());

        if (result.landmarks && result.landmarks.length > 0) {
          const gesture = detectFingerHeart(result.landmarks[0]);
          
          if (gesture === "HEART") {
            targetShape = "HEART";
            statusDiv.innerText = "FINGER HEART ‚ù§Ô∏è";
            statusDiv.style.color = "#ff007f";
          } else if (gesture === "OPEN") {
            targetShape = "SPHERE";
            expansion = 3.0; // Explode size
            statusDiv.innerText = "EXPLODING ‚ú®";
            statusDiv.style.color = "#00ffff";
          } else {
            // Neutral
            targetShape = "SPHERE";
            expansion = 1.0; // Normal size
            statusDiv.innerText = "Hand Detected";
            statusDiv.style.color = "#ffffff";
          }
        } else {
          targetShape = "SPHERE";
          expansion = 1.0;
          statusDiv.innerText = "Show me a sign...";
          statusDiv.style.color = "#888";
        }
      }

      // B. Update Particles
      if (!particles) return;
      const positions = particles.geometry.attributes.position.array;
      const time = Date.now() * 0.001;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        let tx, ty, tz;

        if (targetShape === "HEART") {
          // Move to Heart Shape
          tx = heartPositions[i].x;
          ty = heartPositions[i].y;
          tz = heartPositions[i].z;
          
          // Heartbeat pulse math
          const beat = Math.pow(Math.sin(time * 3), 2) * 0.1 + 0.95; // Beat between 0.95 and 1.05
          tx *= beat; ty *= beat; tz *= beat;

        } else {
          // Move to Sphere (with Expansion factor)
          tx = spherePositions[i].x * expansion;
          ty = spherePositions[i].y * expansion;
          tz = spherePositions[i].z * expansion;
        }

        // Interpolation (Smooth morphing)
        // 0.08 = speed of morphing
        currentPositions[i].x += (tx - currentPositions[i].x) * 0.08;
        currentPositions[i].y += (ty - currentPositions[i].y) * 0.08;
        currentPositions[i].z += (tz - currentPositions[i].z) * 0.08;

        // Add floaty noise
        const noise = (targetShape === "HEART") ? 0.5 : 2.0;
        positions[i3]     = currentPositions[i].x + Math.sin(time + i) * noise;
        positions[i3 + 1] = currentPositions[i].y + Math.cos(time + i) * noise;
        positions[i3 + 2] = currentPositions[i].z;
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      particles.rotation.y += 0.002; // Slow rotation

      renderer.render(scene, camera);
    }

    setupMediaPipe();
  </script>
</body>
</html>

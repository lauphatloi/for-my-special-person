<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Scorpio Galaxy</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background-color: #000;
            overflow-x: hidden;
            font-family: sans-serif;
            color: white;
        }
        
        /* The 3D Canvas */
        .webgl {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            outline: none;
        }

        /* Scroll Spacer */
        .scroll-container {
            position: relative;
            z-index: 2;
            height: 400vh; /* Long scroll area */
            pointer-events: none; /* Let touches pass through to canvas if needed */
        }

        .instruction {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            font-size: 0.9rem;
            opacity: 0.7;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }
    </style>
</head>
<body>

    <canvas class="webgl"></canvas>
    
    <div class="scroll-container">
        <div class="instruction">Scroll slowly to dive in</div>
    </div>

    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.skypack.dev/three@0.132.2"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION ---
        const config = {
            particleCount: 15000,   // Good balance for iPhone 15
            particleSize: 0.06,     // <--- ADJUST SIZE HERE (Smaller = less dazzling)
            galaxyRadius: 5,
            scorpioColor: '#ff8e5e', // The orange/gold color of the sign
            galaxyColor: '#1d2b5e'   // Deep blue background stars
        };

        // --- SETUP ---
        const canvas = document.querySelector('canvas.webgl');
        const scene = new THREE.Scene();
        
        // Fog to hide distant particles and create depth
        scene.fog = new THREE.FogExp2('#000000', 0.15);

        // --- TEXTURE LOADER ---
        const textureLoader = new THREE.TextureLoader();
        
        // ★★★ REPLACE THE URL BELOW WITH YOUR PERSON'S IMAGE ★★★
        // Note: Use a small 100x100px image for best performance!
        const particleTexture = textureLoader.load('https://images.pexels.com/photos/1468379/pexels-photo-1468379.jpeg?_gl=1*cxdyzo*_ga*NTkxNjIyMzQ2LjE3NjU2MDg3MTQ.*_ga_8JE65Q40S6*czE3NjU2MTExNjYkbzIkZzEkdDE3NjU2MTExNzUkajUxJGwwJGgw');

        // --- SCORPIO COORDINATES ---
        // I mapped the shape of Scorpio on a flat plane (X, Z)
        // 0,0 is the center of the screen
        const scorpioPath = [
            { x: -1.5, z: -2.0 }, // Head Top
            { x: -1.8, z: -1.8 }, // Head Mid
            { x: -1.8, z: -1.5 }, // Head Low
            { x: -1.5, z: -1.0 }, // Neck
            { x: -1.0, z: -0.5 }, // Body Upper
            { x: -0.5, z: 0.0 },  // Body Mid
            { x: 0.0, z: 0.5 },   // Body Low
            { x: 0.5, z: 1.0 },   // Tail Start
            { x: 1.2, z: 1.2 },   // Tail Curve Bottom
            { x: 1.8, z: 0.8 },   // Tail Curve Up
            { x: 2.0, z: 0.2 },   // Stinger Base
            { x: 1.8, z: -0.2 }   // Stinger Tip
        ];

        // --- GENERATE GALAXY ---
        let geometry = null;
        let material = null;
        let points = null;

        const generateGalaxy = () => {
            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(config.particleCount * 3);
            const colors = new Float32Array(config.particleCount * 3);
            const scales = new Float32Array(config.particleCount); // To vary size randomly

            const colorInside = new THREE.Color(config.scorpioColor);
            const colorOutside = new THREE.Color(config.galaxyColor);

            for (let i = 0; i < config.particleCount; i++) {
                const i3 = i * 3;
                let x, y, z;

                // --- 1. CREATE SCORPIO SHAPE (First 25% of particles) ---
                if (i < config.particleCount * 0.25) {
                    // Pick a random point along the scorpio path
                    const pointIndex = Math.floor(Math.random() * (scorpioPath.length - 1));
                    const p1 = scorpioPath[pointIndex];
                    const p2 = scorpioPath[pointIndex + 1];
                    
                    // Linear interpolation between points to draw lines
                    const t = Math.random();
                    const basePathX = p1.x + (p2.x - p1.x) * t;
                    const basePathZ = p1.z + (p2.z - p1.z) * t;

                    // Add "Jitter" so it looks like a cloud, not a stick figure
                    // The '0.3' controls how tight the shape is.
                    x = basePathX + (Math.random() - 0.5) * 0.4;
                    y = (Math.random() - 0.5) * 0.4; // Keep it relatively flat
                    z = basePathZ + (Math.random() - 0.5) * 0.4;

                    // Color: Bright Orange
                    colors[i3] = colorInside.r;
                    colors[i3+1] = colorInside.g;
                    colors[i3+2] = colorInside.b;
                    
                    // Make scorpio stars slightly bigger
                    scales[i] = Math.random() * 1.5 + 0.5; 
                } 
                // --- 2. CREATE BACKGROUND GALAXY (Remaining particles) ---
                else {
                    const radius = Math.random() * config.galaxyRadius + 1;
                    const spinAngle = radius * 0.8; // Spiral factor
                    const branchAngle = ((i % 3) / 3) * Math.PI * 2; // 3 Arms

                    const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);
                    const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);
                    const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1);

                    x = Math.cos(branchAngle + spinAngle) * radius + randomX;
                    y = randomY * 2; // More vertical spread for background
                    z = Math.sin(branchAngle + spinAngle) * radius + randomZ;

                    // Color: Mix based on distance
                    const mixedColor = colorInside.clone();
                    mixedColor.lerp(colorOutside, (radius / config.galaxyRadius) + 0.2);

                    colors[i3] = mixedColor.r;
                    colors[i3+1] = mixedColor.g;
                    colors[i3+2] = mixedColor.b;

                    // Normal size
                    scales[i] = Math.random(); 
                }

                positions[i3] = x;
                positions[i3+1] = y;
                positions[i3+2] = z;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));

            // shader modification to support per-particle scaling if needed, 
            // but for simplicity and performance we use standard PointsMaterial
            // with sizeAttenuation.
            
            material = new THREE.PointsMaterial({
                size: config.particleSize,
                sizeAttenuation: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                map: particleTexture,
                transparent: true,
                opacity: 0.9 // Reduce this if still too bright (e.g. 0.6)
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
        }
        
        generateGalaxy();

        // --- RESIZE HANDLER ---
        const sizes = { width: window.innerWidth, height: window.innerHeight };
        window.addEventListener('resize', () => {
            sizes.width = window.innerWidth;
            sizes.height = window.innerHeight;
            camera.aspect = sizes.width / sizes.height;
            camera.updateProjectionMatrix();
            renderer.setSize(sizes.width, sizes.height);
        });

        // --- CAMERA SETUP ---
        const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100);
        
        // Initial Position: HIGH UP (Top Down View)
        camera.position.set(0, 6, 0); 
        camera.lookAt(0, 0, 0);
        
        scene.add(camera);

        // --- RENDERER ---
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
        renderer.setSize(sizes.width, sizes.height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // --- ANIMATION LOOP ---
        const clock = new THREE.Clock();

        const tick = () => {
            const elapsedTime = clock.getElapsedTime();

            // 1. Gentle Rotation (Galaxy spins slowly)
            if(points) {
                points.rotation.y = elapsedTime * 0.05;
            }

            // 2. SCROLL LOGIC
            // Convert scroll pixels to a 0.0 -> 1.0 range
            const scrollY = window.scrollY;
            const maxScroll = document.body.scrollHeight - window.innerHeight;
            const scrollPercent = Math.min(scrollY / maxScroll, 1);

            // Interpolate Camera Position based on Scroll
            // Start (0%): x=0, y=6, z=0 (Top Down)
            // End (100%): x=0, y=0.5, z=3 (Close Up / Perspective)
            
            const startPos = new THREE.Vector3(0, 7, 0.1); // 0.1 z prevents gimbal lock looking down
            const endPos = new THREE.Vector3(0, 0.5, 3.5);

            camera.position.lerpVectors(startPos, endPos, scrollPercent);
            
            // Ensure camera always looks at the center of the galaxy
            camera.lookAt(0, 0, 0);

            // Optional: Zoom effect (FOV change) for speed feeling
            // camera.fov = 75 - (scrollPercent * 10);
            // camera.updateProjectionMatrix();

            renderer.render(scene, camera);
            window.requestAnimationFrame(tick);
        }

        tick();
    </script>
</body>
</html>

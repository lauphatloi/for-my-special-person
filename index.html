<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Magic Mirror: Blink Edition</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    /* UI Overlay */
    #ui {
      position: absolute; bottom: 40px; width: 100%; text-align: center;
      color: rgba(255, 255, 255, 0.6); pointer-events: none;
      z-index: 10;
    }
    #status { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 8px; text-shadow: 0 0 10px #ff007f; }

    /* The Secret Message */
    #secret-message {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      font-family: 'Helvetica', sans-serif;
      font-weight: 800;
      font-size: 2.5rem; 
      color: white;
      text-shadow: 0 0 15px #ff007f, 0 0 30px #ff007f;
      opacity: 0; 
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 20; 
      pointer-events: none;
      white-space: nowrap;
      text-align: center;
      width: 100%;
    }

    /* Floating Phrase Styles */
    .floating-phrase {
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      color: #00ffff;
      font-family: sans-serif;
      font-weight: bold;
      font-size: 1.2rem;
      pointer-events: none;
      white-space: nowrap;
      text-shadow: 0 0 5px #00ffff;
      z-index: 5;
      opacity: 1;
      transition: transform 2s ease-out, opacity 2s ease-out;
    }

    /* Start Screen */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5, 5, 10, 0.95); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; text-align: center;
    }
    button {
      padding: 15px 40px; font-size: 18px; background: white; color: black;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold; margin-top: 25px;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
      transition: transform 0.2s;
    }
    button:active { transform: scale(0.95); }
    button:disabled { background: #555; color: #888; cursor: not-allowed; }
    .icon { font-size: 40px; margin-bottom: 10px; }
  </style>
</head>
<body>

  <!-- CENTER MESSAGE -->
  <div id="secret-message">I LOVE YOU</div>

  <div id="start-screen">
    <div class="icon">âœ¨</div>
    <h1 style="letter-spacing: 3px; text-transform: uppercase; margin:0;">Magic Mirror</h1>
    <p style="font-size:13px; color:#aaa; max-width: 320px; line-height: 1.6; margin-top:15px;">
      1. Smile :) = <span style="color:#ffff00; font-weight:bold;">Surprise</span><br>
      2. Finger Heart = <span style="color:#ff007f; font-weight:bold;">Love</span><br>
      3. Blink ðŸ˜‘ = <span style="color:#00ff00; font-weight:bold;">Change Colors</span>
    </p>
    <button id="start-btn" disabled>LOADING AI...</button>
  </div>

  <div id="ui">
    <div id="status">Loading...</div>
  </div>

  <div id="container"></div>

  <!-- Imports -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker, FaceLandmarker } from "@mediapipe/tasks-vision";

    // ==========================================
    // 1. CUSTOMIZE MESSAGES HERE
    // ==========================================
    const HER_PHRASES = ["Really?", "No way!", "Omg!", "So cute!", "Stop it!", "Haha!", "Magic!"];
    const HEART_MESSAGE = "I LOVE YOU";
    const SMILE_MESSAGE = "You make me happy"; // <--- CHANGE THIS

    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 2800; 
    const SPHERE_RADIUS = 120;
    const HEART_SCALE = 1.6; 
    
    // --- VARIABLES ---
    let camera, scene, renderer, particles;
    let spherePositions = []; 
    let heartPositions = [];  
    let smileyPositions = []; 
    let currentPositions = []; 
    
    let handLandmarker = undefined;
    let faceLandmarker = undefined;
    let video = document.createElement('video');
    
    // Logic State
    let targetShape = "SPHERE"; 
    let expansion = 1.0; 
    let lastVideoTime = -1;
    let lastPhraseTime = 0;
    
    // Blink & Color State
    let wasBlinking = false;
    let isDefaultColors = true;
    let customColorPrimary = new THREE.Color(0xff0055); // Default Red
    let customColorSecondary = new THREE.Color(0xffff00); // Default Yellow

    // Eye Tracking
    let targetLookAt = { x: 0, y: 0 };

    // UI
    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const statusDiv = document.getElementById('status');
    const messageDiv = document.getElementById('secret-message');

    // --- 2. SHAPE MATH ---
    function getSpherePoint() {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = SPHERE_RADIUS * Math.cbrt(Math.random());
      return { 
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi)
      };
    }

    function getHeartPoint() {
      const u = Math.random() * Math.PI;
      const v = Math.random() * Math.PI * 2;
      const x = 16 * Math.pow(Math.sin(u), 3) * Math.cos(v);
      const z = 16 * Math.pow(Math.sin(u), 3) * Math.sin(v); 
      const y = 13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u);
      return { 
        x: x * 5 * HEART_SCALE, 
        y: (y * 5 * HEART_SCALE) + 30, 
        z: z * 5 * HEART_SCALE 
      };
    }

    function getSmileyPoint() {
      const rand = Math.random();
      let x, y, z;
      if (rand < 0.55) {
        // Face Outline 
        const angle = Math.random() * Math.PI * 2;
        const r = 100 + (Math.random() * 10);
        x = Math.cos(angle) * r;
        y = Math.sin(angle) * r;
        z = (Math.random() - 0.5) * 40; 
      } else if (rand < 0.70) {
        // Left Eye
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * 18;
        x = -40 + Math.cos(angle) * r;
        y = 30 + Math.sin(angle) * r;
        z = (Math.random() - 0.5) * 10;
      } else if (rand < 0.85) {
        // Right Eye
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * 18;
        x = 40 + Math.cos(angle) * r;
        y = 30 + Math.sin(angle) * r;
        z = (Math.random() - 0.5) * 10;
      } else {
        // Smile
        const u = Math.random(); 
        const w = 120; 
        x = (u - 0.5) * w; 
        y = ((x*x) * 0.015) - 50; 
        z = (Math.random() - 0.5) * 10;
      }
      return { x: x * 1.1, y: y * 1.1, z: z };
    }

    function initShapes() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        spherePositions.push(getSpherePoint());
        heartPositions.push(getHeartPoint());
        smileyPositions.push(getSmileyPoint());
        currentPositions.push({ ...spherePositions[i] });
      }
    }

    // --- 3. COLOR RANDOMIZER ---
    function triggerRandomColors() {
      isDefaultColors = false;
      const hue = Math.random();
      // Generate two complementary vibrant colors
      customColorPrimary.setHSL(hue, 1.0, 0.6); 
      customColorSecondary.setHSL((hue + 0.5) % 1, 1.0, 0.6);
      
      // Visual feedback
      statusDiv.innerText = "Colors Changed! ðŸŽ¨";
      statusDiv.style.color = "#" + customColorPrimary.getHexString();
    }

    // --- 4. THREE.JS SETUP ---
    function initThree() {
      const container = document.getElementById('container');
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 600; 

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.001);

      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const colors = new Float32Array(PARTICLE_COUNT * 3);
      
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i*3] = currentPositions[i].x;
        positions[i*3+1] = currentPositions[i].y;
        positions[i*3+2] = currentPositions[i].z;
        colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 6, vertexColors: true, blending: THREE.AdditiveBlending,
        depthWrite: false, transparent: true, opacity: 0.9,
        map: createCircleTexture()
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
    }

    function createCircleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 32; canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,32,32);
      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function spawnPhrase() {
      const el = document.createElement('div');
      el.classList.add('floating-phrase');
      el.innerText = HER_PHRASES[Math.floor(Math.random() * HER_PHRASES.length)];
      const startX = (Math.random() - 0.5) * 50; 
      const startY = (Math.random() - 0.5) * 50;
      el.style.transform = `translate(calc(-50% + ${startX}px), calc(-50% + ${startY}px)) scale(0.5)`;
      document.body.appendChild(el);
      el.getBoundingClientRect(); 
      const destX = (Math.random() - 0.5) * window.innerWidth * 0.8;
      const destY = (Math.random() - 0.5) * window.innerHeight * 0.8;
      const rotate = (Math.random() - 0.5) * 60;
      el.style.transform = `translate(calc(-50% + ${destX}px), calc(-50% + ${destY}px)) rotate(${rotate}deg) scale(1.5)`;
      el.style.opacity = '0';
      setTimeout(() => el.remove(), 2000);
    }

    // --- 5. MEDIAPIPE LOGIC ---
    async function setupMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });

      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "CPU"
        },
        outputFaceBlendshapes: true,
        runningMode: "VIDEO",
        numFaces: 1
      });

      startBtn.innerText = "START MAGIC";
      startBtn.disabled = false;
    }

    function detectFingerHeart(landmarks) {
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const wrist = landmarks[0];
      const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
      let otherFingersClosed = true;
      const fingersToCheck = [12, 16, 20];
      const knucklesToCheck = [9, 13, 17];
      for(let i=0; i<3; i++) {
        const tipDist = Math.hypot(landmarks[fingersToCheck[i]].x - wrist.x, landmarks[fingersToCheck[i]].y - wrist.y);
        const knuckleDist = Math.hypot(landmarks[knucklesToCheck[i]].x - wrist.x, landmarks[knucklesToCheck[i]].y - wrist.y);
        if (tipDist > knuckleDist * 1.2) otherFingersClosed = false;
      }
      if (pinchDist < 0.1 && otherFingersClosed) return "HEART";
      const pinkyDist = Math.hypot(landmarks[20].x - wrist.x, landmarks[20].y - wrist.y);
      if (pinkyDist > 0.3 && !otherFingersClosed) return "OPEN";
      return "NEUTRAL";
    }

    startBtn.addEventListener('click', () => {
      startBtn.innerText = "Initializing...";
      navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "user", width: 640, height: 480 } 
      }).then((stream) => {
        video.srcObject = stream;
        video.playsInline = true; 
        video.autoplay = true;
        video.onloadeddata = () => {
          startScreen.style.opacity = 0;
          setTimeout(() => startScreen.style.display = 'none', 1000);
          initShapes();
          initThree();
          loop();
        };
      }).catch(err => alert("Camera error: " + err));
    });

    // --- 6. MAIN LOOP ---
    async function loop() {
      requestAnimationFrame(loop);

      let detectedGesture = "NONE";
      let isSmiling = false;

      // A. VISION PROCESSING
      if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const now = performance.now();

        // 1. Hand Detection
        if (handLandmarker) {
          const result = handLandmarker.detectForVideo(video, now);
          if (result.landmarks && result.landmarks.length > 0) {
            detectedGesture = detectFingerHeart(result.landmarks[0]);
          }
        }

        // 2. Face Detection (Smile + Blink + Gaze)
        if (faceLandmarker) {
          const faceResult = faceLandmarker.detectForVideo(video, now);
          if (faceResult.faceBlendshapes && faceResult.faceBlendshapes.length > 0) {
            const categories = faceResult.faceBlendshapes[0].categories;
            
            // Smile Logic
            const smileLeft = categories.find(c => c.categoryName === 'mouthSmileLeft')?.score || 0;
            const smileRight = categories.find(c => c.categoryName === 'mouthSmileRight')?.score || 0;
            if ((smileLeft + smileRight) / 2 > 0.45) isSmiling = true;

            // Blink Logic
            const blinkLeft = categories.find(c => c.categoryName === 'eyeBlinkLeft')?.score || 0;
            const blinkRight = categories.find(c => c.categoryName === 'eyeBlinkRight')?.score || 0;
            const isBlinkingNow = (blinkLeft > 0.5 && blinkRight > 0.5);

            // Trigger Color Change on Blink Start
            if (isBlinkingNow && !wasBlinking) {
               triggerRandomColors();
            }
            wasBlinking = isBlinkingNow;
          }

          // Simple Gaze Tracking (Nose direction)
          if (faceResult.faceLandmarks && faceResult.faceLandmarks.length > 0) {
             const nose = faceResult.faceLandmarks[0][1]; // Tip of nose
             // Map 0..1 to Screen Coordinates (Inverted X for mirror feel)
             targetLookAt.x = (nose.x - 0.5) * -400; 
             targetLookAt.y = (nose.y - 0.5) * -400; 
          }
        }
      }

      // B. STATE MANAGEMENT
      if (detectedGesture === "HEART") {
        targetShape = "HEART";
        statusDiv.innerText = "â¤ï¸";
        if(isDefaultColors) statusDiv.style.color = "#ff007f";
        messageDiv.innerText = HEART_MESSAGE;
        messageDiv.style.opacity = 1;
        messageDiv.style.transform = "translate(-50%, -50%) scale(1)";

      } else if (isSmiling) {
        targetShape = "SMILEY";
        statusDiv.innerText = "ðŸ˜Š";
        if(isDefaultColors) statusDiv.style.color = "#ffff00";
        messageDiv.innerText = SMILE_MESSAGE;
        messageDiv.style.opacity = 1;
        messageDiv.style.transform = "translate(-50%, -50%) scale(1)";

      } else if (detectedGesture === "OPEN") {
        targetShape = "SPHERE";
        expansion = 3.0; 
        statusDiv.innerText = "âœ¨";
        if(isDefaultColors) statusDiv.style.color = "#00ffff";
        messageDiv.style.opacity = 0;
        messageDiv.style.transform = "translate(-50%, -50%) scale(0.5)";
        
        if (Date.now() - lastPhraseTime > 350) {
          spawnPhrase();
          lastPhraseTime = Date.now();
        }

      } else {
        targetShape = "SPHERE";
        expansion = 1.0; 
        statusDiv.innerText = "Blink to change colors";
        statusDiv.style.color = "#ffffff";
        messageDiv.style.opacity = 0;
        messageDiv.style.transform = "translate(-50%, -50%) scale(0.5)";
      }

      // C. PARTICLE ANIMATION
      if (!particles) return;
      const positions = particles.geometry.attributes.position.array;
      const colors = particles.geometry.attributes.color.array;
      const time = Date.now() * 0.001;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        let tx, ty, tz;
        let targetColor = { r:1, g:1, b:1 };
        let moveSpeed = 0.08;

        // 1. Determine Position & Default Color
        if (targetShape === "HEART") {
          tx = heartPositions[i].x; ty = heartPositions[i].y; tz = heartPositions[i].z;
          const beat = Math.pow(Math.sin(time * 3), 2) * 0.05 + 0.95; 
          tx *= beat; ty *= beat; tz *= beat;
          targetColor = { r:1, g:0, b:0.33 }; // Default Red

        } else if (targetShape === "SMILEY") {
          tx = smileyPositions[i].x; ty = smileyPositions[i].y; tz = smileyPositions[i].z;
          targetColor = { r:1, g:1, b:0 }; // Default Yellow
          moveSpeed = 0.2; // Snap fast

        } else {
          tx = spherePositions[i].x * expansion;
          ty = spherePositions[i].y * expansion;
          tz = spherePositions[i].z * expansion;
          targetColor = (i%2==0) ? {r:0, g:1, b:1} : {r:1, g:1, b:1}; // Cyan/White
        }

        // 2. Apply Custom Colors (If Blinked)
        if (!isDefaultColors) {
          let c = (i % 2 === 0) ? customColorPrimary : customColorSecondary;
          targetColor = { r: c.r, g: c.g, b: c.b };
        }

        // 3. Movement Physics (with Eye Gaze Attraction)
        // Add subtle pull towards where nose is pointing
        if (targetShape === "SPHERE" && expansion === 1.0) {
           tx += targetLookAt.x * 0.5; // Influence factor
           ty -= targetLookAt.y * 0.5; // Invert Y
        }

        currentPositions[i].x += (tx - currentPositions[i].x) * moveSpeed;
        currentPositions[i].y += (ty - currentPositions[i].y) * moveSpeed;
        currentPositions[i].z += (tz - currentPositions[i].z) * moveSpeed;

        const noise = (targetShape !== "SPHERE") ? 0.3 : 2.0;
        positions[i3]     = currentPositions[i].x + Math.sin(time + i) * noise;
        positions[i3 + 1] = currentPositions[i].y + Math.cos(time + i) * noise;
        positions[i3 + 2] = currentPositions[i].z;

        // 4. Color Interpolation
        colors[i3]   += (targetColor.r - colors[i3]) * 0.05;
        colors[i3+1] += (targetColor.g - colors[i3+1]) * 0.05;
        colors[i3+2] += (targetColor.b - colors[i3+2]) * 0.05;
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.color.needsUpdate = true;
      particles.rotation.y += 0.002;

      renderer.render(scene, camera);
    }

    setupMediaPipe();
  </script>
</body>
</html>

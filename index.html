<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Ocean Gaze - iPhone 15</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
    
    /* Hidden Layer */
    #hidden-layer {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(circle at center, #10051f 0%, #000000 100%);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 1; 
    }

    .message {
      color: #fff;
      font-family: 'Helvetica', sans-serif;
      font-weight: 800;
      font-size: 2.5rem;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 5px;
      text-shadow: 0 0 20px #ff007f, 0 0 40px #00ffff;
      opacity: 0.9;
    }
    
    .sub-text {
      font-size: 1rem; color: #aaa; margin-top: 20px;
      font-weight: normal; letter-spacing: 2px;
    }

    /* Canvas Layer */
    canvas { 
      display: block; width: 100vw; height: 100vh; 
      position: absolute; top: 0; left: 0;
      z-index: 2; 
    }
    
    /* UI Overlay */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.95); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; text-align: center;
    }
    button {
      padding: 15px 40px; font-size: 18px; background: white; color: black;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold; margin-top: 25px;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    }
    #debug {
      position: absolute; top: 50px; left: 10px; color: lime; 
      font-size: 10px; z-index: 50; pointer-events: none; opacity: 0.5;
    }
  </style>
</head>
<body>

  <!-- HIDDEN CONTENT -->
  <div id="hidden-layer">
    <div class="message">
      I See<br>You
    </div>
    <div class="sub-text">Blink to make waves</div>
  </div>

  <!-- START SCREEN -->
  <div id="start-screen">
    <div style="font-size:50px; margin-bottom:10px">üëÅÔ∏è</div>
    <h1 style="letter-spacing: 3px; margin:0;">Deep Gaze</h1>
    <p style="font-size:13px; color:#aaa; margin-top:15px; max-width: 80%;">
      High Sensitivity Mode.<br>
      Move your EYES, not your head.
    </p>
    <button id="start-btn">START</button>
  </div>

  <div id="debug">Initializing...</div>
  <div id="container"></div>

  <!-- IMPORTS -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, FaceLandmarker } from "@mediapipe/tasks-vision";

    let camera, scene, renderer, mesh;
    let faceLandmarker = undefined;
    let video = document.createElement('video');
    let lastVideoTime = -1;

    // Logic Variables
    let gazeX = 0.5, gazeY = 0.5;
    let targetGazeX = 0.5, targetGazeY = 0.5;
    let blinkStrength = 0.0;

    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const debugDiv = document.getElementById('debug');

    // --- 1. SHADER (EYE SHAPE & SMALLER) ---
    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const fragmentShader = `
      uniform float uTime;
      uniform vec2 uResolution;
      uniform vec2 uGaze;      
      uniform float uBlink;    

      varying vec2 vUv;

      // Noise
      float random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
      float noise (in vec2 st) {
          vec2 i = floor(st); vec2 f = fract(st);
          float a = random(i); float b = random(i + vec2(1.0, 0.0));
          float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
          vec2 u = f * f * (3.0 - 2.0 * f);
          return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }

      void main() {
        vec2 uv = vUv;
        
        // Correct Aspect Ratio for distances
        float aspect = uResolution.x / uResolution.y;
        vec2 uvCorrected = uv;
        uvCorrected.x *= aspect;
        
        vec2 gazeCorrected = uGaze;
        gazeCorrected.x *= aspect;

        // 1. WATER LAYER
        float n = noise(uv * 3.0 + uTime * 0.15);
        n += noise(uv * 6.0 - uTime * 0.2) * 0.5;
        
        // 2. SHAPE CALCULATION (The Eye Shape)
        // Vector from current pixel to gaze point
        vec2 distVec = uvCorrected - gazeCorrected;
        
        // IMPORTANT: Stretch Y to make it an Eye/Almond shape
        distVec.y *= 1.8; 
        
        float distToGaze = length(distVec);

        // 3. SIZE & EDGES
        // Smaller hole: 0.05 to 0.25 (Was 0.15 to 0.35)
        float holeSize = 0.08; 
        float edgeSoftness = 0.22;
        float gazeMask = smoothstep(holeSize, edgeSoftness, distToGaze); 
        
        // Liquid edges
        gazeMask += noise(uv * 12.0 + uTime) * 0.08;
        gazeMask = clamp(gazeMask, 0.0, 1.0);

        // 4. BLINK RIPPLE
        float distFromCenter = distance(uvCorrected, vec2(0.5 * aspect, 0.5));
        float rippleRadius = uBlink * 3.0; 
        float ripple = 0.0;
        if(uBlink > 0.01) {
           ripple = sin(distFromCenter * 30.0 - uTime * 8.0) * uBlink;
        }

        // 5. COLORS
        vec3 deepBlue = vec3(0.02, 0.05, 0.15);
        vec3 brightCyan = vec3(0.0, 0.5, 0.7);
        vec3 color = mix(deepBlue, brightCyan, n * 0.6 + 0.1);
        
        // Add brightness from ripple
        color += vec3(ripple);

        gl_FragColor = vec4(color, gazeMask * 0.98); 
      }
    `;

    // --- 2. THREE.JS ---
    function initThree() {
      const container = document.getElementById('container');
      
      camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
      scene = new THREE.Scene();
      const geometry = new THREE.PlaneGeometry(2, 2);
      
      const uniforms = {
        uTime: { value: 0 },
        uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        uGaze: { value: new THREE.Vector2(0.5, 0.5) },
        uBlink: { value: 0.0 }
      };

      const material = new THREE.ShaderMaterial({
        vertexShader, fragmentShader, uniforms, transparent: true
      });

      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      renderer = new THREE.WebGLRenderer({ alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
    }

    // --- 3. VISION & SENSITIVITY ---
    async function setupFaceLandmarker() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      
      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO",
        numFaces: 1,
        refineLandmarks: true 
      });
      startBtn.innerText = "START EXPERIENCE";
      startBtn.disabled = false;
    }

    function analyzeFace(landmarks) {
      // A. BLINK
      const leftEyeDist = Math.hypot(landmarks[159].x - landmarks[145].x, landmarks[159].y - landmarks[145].y);
      const rightEyeDist = Math.hypot(landmarks[386].x - landmarks[374].x, landmarks[386].y - landmarks[374].y);
      const faceScale = Math.hypot(landmarks[33].x - landmarks[263].x, landmarks[33].y - landmarks[263].y);
      const eyeOpenness = (leftEyeDist + rightEyeDist) / 2 / faceScale;

      if (eyeOpenness < 0.035) {
         blinkStrength = 1.0; 
         debugDiv.innerText = "BLINKING";
      } else {
         blinkStrength *= 0.94;
      }

      // B. GAZE (HIGH SENSITIVITY)
      const iris = landmarks[468]; 
      const nose = landmarks[1]; 

      // SENSITIVITY FACTOR: Increased from 2.5 to 7.0
      // This means small eye movements translate to BIG screen movements
      const sensitivity = 7.0; 
      
      const dx = (nose.x - iris.x) * sensitivity;
      const dy = (nose.y - iris.y) * sensitivity;

      let rawX = 0.5 + dx;
      let rawY = 0.5 + dy;

      // Invert X for mirror effect
      rawX = 1.0 - rawX;

      // Clamp
      targetGazeX = Math.max(0, Math.min(1, rawX));
      targetGazeY = Math.max(0, Math.min(1, rawY));
      
      if(blinkStrength < 0.1) debugDiv.innerText = `Gaze: ${rawX.toFixed(2)}, ${rawY.toFixed(2)}`;
    }

    startBtn.addEventListener('click', () => {
      startBtn.innerText = "Loading...";
      navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "user", width: 640, height: 480 } 
      }).then((stream) => {
        video.srcObject = stream;
        video.playsInline = true; 
        video.autoplay = true;
        video.onloadeddata = () => {
          startScreen.style.opacity = 0;
          setTimeout(() => startScreen.style.display = 'none', 1000);
          initThree();
          loop();
        };
      }).catch(err => alert("Camera error: " + err));
    });

    function loop() {
      requestAnimationFrame(loop);

      if (faceLandmarker && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const result = faceLandmarker.detectForVideo(video, performance.now());
        if (result.faceLandmarks && result.faceLandmarks.length > 0) {
          analyzeFace(result.faceLandmarks[0]);
        }
      }

      // Smoothing (Lerp)
      // 0.1 gives a bit of lag for smoothness. Increase to 0.2 for snappier response.
      gazeX += (targetGazeX - gazeX) * 0.1;
      gazeY += (targetGazeY - gazeY) * 0.1;

      if (mesh) {
        mesh.material.uniforms.uTime.value = performance.now() / 1000;
        mesh.material.uniforms.uGaze.value.set(gazeX, 1.0 - gazeY); 
        mesh.material.uniforms.uBlink.value = blinkStrength;
      }
      if(renderer) renderer.render(scene, camera);
    }

    setupFaceLandmarker();
  </script>
</body>
</html>

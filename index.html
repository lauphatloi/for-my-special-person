<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Real Love Magic</title>
  <style>
    body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', sans-serif; }
    canvas { display: block; width: 100vw; height: 100vh; }
    
    /* UI Overlay */
    #ui {
      position: absolute; bottom: 40px; width: 100%; text-align: center;
      color: rgba(255, 255, 255, 0.6); pointer-events: none;
      z-index: 10;
    }
    #status { font-size: 1.5rem; font-weight: bold; color: white; margin-bottom: 8px; text-shadow: 0 0 10px #ff007f; }
    .sub { font-size: 0.9rem; letter-spacing: 1px; color: #ccc; }

    /* The Secret Message */
    #secret-message {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%) scale(0.5);
      font-family: 'Helvetica', sans-serif;
      font-weight: 800;
      font-size: 2.5rem; 
      color: white;
      text-shadow: 0 0 15px #ff007f, 0 0 30px #ff007f;
      opacity: 0; /* Hidden by default */
      transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 5; 
      pointer-events: none;
      white-space: nowrap;
      text-align: center;
    }

    /* Start Screen */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5, 5, 10, 0.95); z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; text-align: center;
    }
    button {
      padding: 15px 40px; font-size: 18px; background: white; color: black;
      border: none; border-radius: 50px; cursor: pointer; font-weight: bold; margin-top: 25px;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    }
    .icon { font-size: 40px; margin-bottom: 10px; }
  </style>
</head>
<body>

  <div id="secret-message">Báº¯n TYM</div>

  <div id="start-screen">
    <div class="icon">ðŸ«°</div>
    <h1 style="letter-spacing: 3px; text-transform: uppercase; margin:0;">Magic</h1>
    <p style="font-size:13px; color:#aaa; max-width: 320px; line-height: 1.6; margin-top:15px;">
      1. Open Hand = <span style="color:#00ffff">Explode</span><br>
      2. Finger Heart = <span style="color:#ff007f; font-weight:bold;">Reveal </span>
    </p>
    <button id="start-btn">START</button>
  </div>

  <div id="ui">
    <div id="status">Waiting for hand...</div>
    <div class="sub">Make the Finger Heart gesture ðŸ«°</div>
  </div>

  <div id="container"></div>

  <!-- Imports -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 2200; // Increased for a denser heart shell
    const SPHERE_RADIUS = 120;
    const HEART_SCALE = 1.6; // Adjusted scale for the new formula
    
    // --- VARIABLES ---
    let camera, scene, renderer, particles;
    let spherePositions = []; 
    let heartPositions = [];  
    let currentPositions = []; 
    
    let handLandmarker = undefined;
    let video = document.createElement('video');
    
    // Logic State
    let targetShape = "SPHERE"; 
    let expansion = 1.0; 
    let lastVideoTime = -1;

    // UI
    const startBtn = document.getElementById('start-btn');
    const startScreen = document.getElementById('start-screen');
    const statusDiv = document.getElementById('status');
    const messageDiv = document.getElementById('secret-message');

    // --- 1. SHAPE MATH (UPGRADED) ---
    function getSpherePoint() {
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      const r = SPHERE_RADIUS * Math.cbrt(Math.random());
      return { 
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi)
      };
    }

    // NEW REALISTIC SHELL FORMULA
    function getHeartPoint() {
      // We use a parametric surface to make a hollow shell (more realistic outline)
      // u range: 0 to PI
      // v range: 0 to 2PI
      const u = Math.random() * Math.PI;
      const v = Math.random() * Math.PI * 2;
      
      // Heart Formula
      const x = 16 * Math.pow(Math.sin(u), 3) * Math.cos(v);
      const z = 16 * Math.pow(Math.sin(u), 3) * Math.sin(v); // depth
      const y = 13 * Math.cos(u) - 5 * Math.cos(2*u) - 2 * Math.cos(3*u) - Math.cos(4*u);

      // Scale factors to match screen size (Multiplied by 5 then by HEART_SCALE)
      return { 
        x: x * 5 * HEART_SCALE, 
        y: (y * 5 * HEART_SCALE) + 30, // Move up slightly
        z: z * 5 * HEART_SCALE 
      };
    }

    function initShapes() {
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        spherePositions.push(getSpherePoint());
        heartPositions.push(getHeartPoint());
        currentPositions.push({ ...spherePositions[i] });
      }
    }

    // --- 2. THREE.JS SETUP ---
    function initThree() {
      const container = document.getElementById('container');
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.z = 600; // Pulled back slightly to see full heart

      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.001);

      // Geometry
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(PARTICLE_COUNT * 3);
      const colors = new Float32Array(PARTICLE_COUNT * 3);
      
      const c1 = new THREE.Color(0xff0055); // Red/Pink
      const c2 = new THREE.Color(0xffffff); // White
      const c3 = new THREE.Color(0xff69b4); // Hot Pink

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i*3] = currentPositions[i].x;
        positions[i*3+1] = currentPositions[i].y;
        positions[i*3+2] = currentPositions[i].z;

        // Color mix
        let c = Math.random() > 0.4 ? c1 : c3;
        if(Math.random() > 0.95) c = c2; 
        colors[i*3] = c.r;
        colors[i*3+1] = c.g;
        colors[i*3+2] = c.b;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      // Circular Particles
      const material = new THREE.PointsMaterial({
        size: 5.5, // Slightly refined size
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.9,
        map: createCircleTexture()
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(renderer.domElement);
    }

    function createCircleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 32; canvas.height = 32;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,32,32);
      const tex = new THREE.Texture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    // --- 3. MEDIAPIPE & GESTURE LOGIC (YOUR PREFERRED LOGIC) ---
    async function setupMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
          delegate: "CPU"
        },
        runningMode: "VIDEO",
        numHands: 1
      });
      startBtn.innerText = "START MAGIC";
      startBtn.disabled = false;
    }

    // KEEPING YOUR LOGIC EXACTLY AS REQUESTED
    function detectFingerHeart(landmarks) {
      const thumbTip = landmarks[4];
      const indexTip = landmarks[8];
      const wrist = landmarks[0];

      // 1. Calculate Pinch Distance (Thumb to Index)
      const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);

      // 2. Check if other fingers are CLOSED
      let otherFingersClosed = true;
      const fingersToCheck = [12, 16, 20]; // Middle, Ring, Pinky
      const knucklesToCheck = [9, 13, 17];
      
      for(let i=0; i<3; i++) {
        const tipDist = Math.hypot(landmarks[fingersToCheck[i]].x - wrist.x, landmarks[fingersToCheck[i]].y - wrist.y);
        const knuckleDist = Math.hypot(landmarks[knucklesToCheck[i]].x - wrist.x, landmarks[knucklesToCheck[i]].y - wrist.y);
        
        if (tipDist > knuckleDist * 1.2) {
          otherFingersClosed = false;
        }
      }

      // --- LOGIC ---
      if (pinchDist < 0.1 && otherFingersClosed) {
        return "HEART";
      }

      const pinkyDist = Math.hypot(landmarks[20].x - wrist.x, landmarks[20].y - wrist.y);
      if (pinkyDist > 0.3 && !otherFingersClosed) {
        return "OPEN";
      }

      return "NEUTRAL";
    }

    startBtn.addEventListener('click', () => {
      startBtn.innerText = "Initializing...";
      navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: "user", width: 640, height: 480 } 
      }).then((stream) => {
        video.srcObject = stream;
        video.playsInline = true; 
        video.autoplay = true;
        video.onloadeddata = () => {
          startScreen.style.opacity = 0;
          setTimeout(() => startScreen.style.display = 'none', 1000);
          initShapes();
          initThree();
          loop();
        };
      }).catch(err => alert("Camera blocked: " + err));
    });

    // --- 4. ANIMATION LOOP ---
    async function loop() {
      requestAnimationFrame(loop);

      // A. Detect Hand
      if (handLandmarker && video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        const result = handLandmarker.detectForVideo(video, performance.now());

        if (result.landmarks && result.landmarks.length > 0) {
          const gesture = detectFingerHeart(result.landmarks[0]);
          
          if (gesture === "HEART") {
            targetShape = "HEART";
            statusDiv.innerText = "Cá»­ chá»‰ hay Ä‘Æ°á»£c bÃ  dÃ¹ng nÃ¨ !!! ðŸ«°";
            statusDiv.style.color = "#ff007f";
            
            // SHOW MESSAGE
            messageDiv.style.opacity = 1;
            messageDiv.style.transform = "translate(-50%, -50%) scale(1)";

          } else if (gesture === "OPEN") {
            targetShape = "SPHERE";
            expansion = 3.0; // Explode size
            statusDiv.innerText = "âœ¨";
            statusDiv.style.color = "#00ffff";
            
            // HIDE MESSAGE
            messageDiv.style.opacity = 0;
            messageDiv.style.transform = "translate(-50%, -50%) scale(0.5)";

          } else {
            // Neutral
            targetShape = "SPHERE";
            expansion = 1.0; 
            statusDiv.innerText = "Hand Detected";
            statusDiv.style.color = "#ffffff";
            
            // HIDE MESSAGE
            messageDiv.style.opacity = 0;
            messageDiv.style.transform = "translate(-50%, -50%) scale(0.5)";
          }
        } else {
          targetShape = "SPHERE";
          expansion = 1.0;
          statusDiv.innerText = "Show me a sign...";
          statusDiv.style.color = "#888";
          messageDiv.style.opacity = 0;
        }
      }

      // B. Update Particles
      if (!particles) return;
      const positions = particles.geometry.attributes.position.array;
      const time = Date.now() * 0.001;

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        const i3 = i * 3;
        
        let tx, ty, tz;

        if (targetShape === "HEART") {
          tx = heartPositions[i].x;
          ty = heartPositions[i].y;
          tz = heartPositions[i].z;
          
          // Heartbeat pulse math
          const beat = Math.pow(Math.sin(time * 3), 2) * 0.05 + 0.95; 
          tx *= beat; ty *= beat; tz *= beat;
        } else {
          tx = spherePositions[i].x * expansion;
          ty = spherePositions[i].y * expansion;
          tz = spherePositions[i].z * expansion;
        }

        // Smooth Interpolation
        currentPositions[i].x += (tx - currentPositions[i].x) * 0.08;
        currentPositions[i].y += (ty - currentPositions[i].y) * 0.08;
        currentPositions[i].z += (tz - currentPositions[i].z) * 0.08;

        // Add floaty noise
        // IMPORTANT: Low noise for Heart (0.1) so shape is distinct and message is visible
        const noise = (targetShape === "HEART") ? 0.1 : 2.0;
        
        positions[i3]     = currentPositions[i].x + Math.sin(time + i) * noise;
        positions[i3 + 1] = currentPositions[i].y + Math.cos(time + i) * noise;
        positions[i3 + 2] = currentPositions[i].z;
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      particles.rotation.y += 0.002; // Slow rotation

      renderer.render(scene, camera);
    }

    setupMediaPipe();
  </script>
</body>
</html>
